#
# Snippets for Genesis/LPC
# ========================
#
# Rooms:
#  - create_room
#  - create_inn
#  - create_post
#  - create_bank
#  - create_chapel
#  - create_shop
#  - create_storeroom
#  - create_training
#
# Armours:
#  - create_armour
#  - create_magical_armour
#  - create_wearable
#
# Weapons:
#  - create_weapon
#  - create_poison_weapon
#  - create_magical_weapon
#
# Containers:
#  - create_backpack
#  - create_bag
#  - create_chest
#  - create_trapped_chest
#  - herbal jar?
#
# Rope:
#  - create_rope
#
# Light sources:
#  - create_torch
#
# Valuables:
#  - create_gem
#
# Scrolls and books:
#  - create_scroll-
#
# Herbs and potions
#  - create_potion-
#  - create_herb-
#
# Misc items:
#  - create_object
#  - create_food
#  - create_drink
#  - create_message (carried by messengers)
#  - create_holdable
# 
# NPCs:
#  - create_npc
#  - create_creature
#  - create_messenger
#
# Utilities:
#  - qwrap



#
# Py helpers
# {{{
global !p
import textwrap

def qwrap(text, clean = False):
  r = re.sub(r'[\t\s\r\n]+', ' ', text, flags=re.MULTILINE)
  if clean: r = re.sub(r'["\'\s/*+]+', ' ', r)
  r = r.strip()
  r = textwrap.wrap(r, 60, initial_indent=" \"",
					subsequent_indent="\t\t\t+ \"",
					expand_tabs=False)
  r = " \"\n".join(r)
  if not clean and len(r) > 0 : r += "\\n"
  r = r + "\"" if r != "" else "\"\""
  return r

def clean_description():
  if snip.tabstop != 0 : return
  r = re.compile(r'/\*-{|}-\*/')
  indices = [ i for i, line in enumerate(snip.buffer) if r.search(line) ]
  if len(indices) % 2 != 0 : return
  for i in xrange(len(indices), 0, -2):
	  [ s, e ] = indices[i-2:i]
	  snip.buffer[s : e+1] = []

endglobal
# }}}

#
# File skeletons
# {{{
context "snip.line == 0 and len(snip.buffer) == 1"
snippet "^room$" "Create a room (full file skeleton)" br
...full skeleton...
endsnippet
# }}}

#
# Visual snippets
# {{{
snippet qwrap "Rewrap string or comment into wrapped string" i
`!p snip.rv = qwrap(snip.v.text, True)`
endsnippet
#}}}

#
# Rooms
# {{{
post_jump "clean_description()"
snippet create_room "Create a room" b
/*
 * Function name: create_room
 * Description	: $1
 */
public void
create_room()
{
	set_short("${1:Short description}");

	/*-{
		Description: 
					${2:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[2])`);

	add_item(({ ${3:Item} }), "${4:Item description}\n");

	add_cmd_item(({ "${5:Item}" }), ({ "${6:Command}" }), 
		({ "${7:Effect description}" }));

	add_prop(ROOM_I_INSIDE, ${8:0-1});
	add_prop(ROOM_I_LIGHT, ${9:1});	  
	add_prop(ROOM_I_TYPE, ROOM_${10:NORMAL|IN_AIR|IN_WATER|UNDER_WATER|BEACH});

	add_prop(ROOM_I_NO_ALLOW_STEED, ${11:0-1});
	add_prop(ROOM_M_NO_ATTACK, ${12:0-1});

	add_prop(OBJ_S_SEARCH_FUN, "search");

	add_exit("${13:relative/path/to/other/room}", 
			"${14:direction}", "${15:VBFC}", ${16:fatigue});

	// Room content
	add_npc("${17:/path/to/npc}", ${18:1 - count}, ${19:&->arm_me()});
	add_object("${20:/path/to/object}", ${21:1 - count}, ${22:&->obj_prep()});

	reset_room();
}

/*
 * Function name: reset_room
 * Description	: initialize room state
 */
public void
reset_room()
{
	::reset_room();
}

public void
init()
{
	::init();

	add_action(act_fn, "action_name");
}

/*
 * Function name: search
 * Argument     : object player - player conducting the search
 * Argument     : string item - item that is being searched
 * Description  : respond to player search action
 * Returns      : "text" - the "text" will be printed to the player to inform him of the
 *                         result of the search (whether it is good or bad).
 *                ""     - no text will be printed to the player. This assumes that you have
 *                         taken care of the message within your routine.
 *                0      - the search failed. A default fail message will be printed.
 */
public string
search(object player, object item)
{
	return 0;
}

/*
 * Function name: block_action
 * Description:   Called to see if this room wants to prevent a living
 *				  inside from performing an action.  This will be called
 *				  once for each target.
 * Arguments:	  string cmd - the command name
 *				  object actor - the actor
 *				  object target - the target of the action
 *				  int cmd_attrs - the command's attributes (from cmdparse.h)
 * Returns:		  0 - Command allowed
 *				  1 - Command blocked without a failure message
 *				  string - Command blocked, use return value as failure message
 */
public mixed
block_action(string cmd, object actor, object target, int cmd_attrs)
{
	/* The room prevents high activity actions */
	if (cmd_attrs & ACTION_HACTIVITY)
	{
		return "The tunnel is too tight to move around in.\n";
	}

	/* All other actions use the default */
	return ::block_action(cmd, actor, target, cmd_attrs);
}
$0
endsnippet

post_jump "clean_description()"
snippet create_inn "Create inn" b
/*
 * Function name: create_room
 * Description  : $1
 */
void
create_room()
{
	set_short("${1:Wild Boar Inn}");

	/*-{
		Description: 
					${2:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[2])`);

	add_item(({ ${3:bar} }), 
		"${4:A nice looking wooden bar with a menu on it.}\n");

	add_cmd_item(({ "${5:menu}" }), ({ "${6:read}" }), "${7:@@read_menu}");

	add_prop(ROOM_I_INSIDE, ${8:1});
	add_prop(ROOM_I_LIGHT, ${9:1});
	add_prop(ROOM_I_TYPE, ROOM_${10:NORMAL});

	add_prop(ROOM_I_NO_ALLOW_STEED, ${11:1});
	add_prop(ROOM_M_NO_ATTACK, ${12:0});

	add_exit("${13:/path/to/inn/exit}", 
			"${14:out}", "${15:VBFC}");

	add_npc("${17:/path/to/bartender}", ${18:1}, ${19:&->equip_me()});

	add_drink( ({ ${20:"beer", "beers", "small", "small beer"} }),
	"${21:beer}", "${22:small}", 
	${23:100 - soft amount}, ${24:20 - alco ammount}, ${25:12 - price}, 
	${26:0 - special short description}, ${27:0 - plural spec short description},
	"${28:It's a small but refreshing beer.}\n", 0);

	add_food( ({ ${29:"potatoes", "spiced", "plate of spiced potatoes",
		 "plate", "plates"} }),
	"${30:potatoes}", "${31:spiced}", ${32:110 - weight}, ${33:110 - price}, 
	${34:"plate of spiced potatoes"}, ${35:"plates of spiced potatoes"},
	"${36:They look very tasty.}\n", 0);
}

/*
 * Function name: read_menu
 * Description:   Read the menu
 */
int
read_menu(string str)
{
	write("---------------------------------------" +
		"	Small beer				   12 cc\n" +
		"	Plate of spiced potatoes  210 cc\n" +
		"---------------------------------------\n\n");
	return 1;
}

/*
 * Function name: init
 * Description:   Initalize the pub actions
 */
void
init()
{
	::init();
	init_pub();
}
endsnippet

post_jump "clean_description()"
snippet create_post "Create post office" b
/*
 * Function name: create_room
 * Description  : $1
 */
void
create_room()
{
	set_short("${1:Post Office of Gelan}");

	/*-{
		Description: 
					${2:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[2])` + 
			get_std_use());

	add_item(({ ${3:"elves", "elf"} }),
		"${4:The elves are hurriedly sorting all the mail that " +
		"needs to be delivered. They don't have time to talk " +
		"to you.}\n");

	add_item (({ ${5:"head postmaster", "postmaster"} }),
		"${6:He's supervising his employees, making sure " +
		"they do their work properly.}\n");

	add_prop(ROOM_I_INSIDE, ${7:1});
	add_prop(ROOM_I_LIGHT, ${8:1});
	add_prop(ROOM_I_TYPE, ROOM_${9:NORMAL});

	add_prop(ROOM_I_NO_ALLOW_STEED, ${10:1});
	add_prop(ROOM_M_NO_ATTACK, ${11:0});

	add_exit("${12:/path/to/post/office/exit}", 
			"${13:out}", "${14:VBFC}");

	add_npc("${16:/path/to/postmaster}", ${17:1}, ${18:&->equip_me()});
}

/*
 * Function name: init
 * Description:   Initalize the post office actions
 */
void
init()
{
	::init();
	post_init();
}

/*
 * Function name: leave_inv
 * Description:   return the post office folder
 */
void
leave_inv(object ob, mixed to)
{
	::leave_inv(ob, to);
	post_leave_inv(ob, to);
}
endsnippet

post_jump "clean_description()"
snippet create_bank "Create a bank" b
/*
 * Function name: create_room
 * Description  : $1
 */
void
create_room()
{
	set_short("${1:The Bank Office}");

	/*-{
		Description: 
					${2:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[2])`);

	add_item( ({ ${3:"sign", "instructions"} }), ${4:standard_bank_sign});
	add_cmd_item( ({ ${5:"sign", "instructions"} }), "${6:read}", ${7:standard_bank_sign});

	add_prop(ROOM_I_INSIDE, ${8:1});
	add_prop(ROOM_I_LIGHT, ${9:1});
	add_prop(ROOM_I_TYPE, ROOM_${10:NORMAL});

	add_prop(ROOM_I_NO_ALLOW_STEED, ${11:1});
	add_prop(ROOM_M_NO_ATTACK, ${12:0});

	add_exit("${13:/path/to/bank/exit}", 
			"${14:out}", "${15:VBFC}");

	set_bank_fee(${16:30 - exchange fee [%]}); 
	config_trade_data();

	add_npc("${17:/path/to/banker}", ${18:1}, ${19:&->equip_me()});
}

/*
 * Function name: init
 * Description:   Initalize the bank actions
 */
void
init()
{
	::init();
	bank_init();
}
endsnippet

post_jump "clean_description()"
snippet create_chapel "Create a chapel" b
/*
 * Function name: create_room
 * Description	: $1
 */
void
create_room()
{ 
	set_short("${1:The Chapel}");

	/*-{
		Description: 
					${2:Long description, suggest <meditate> command}
	}-*/
	set_long(`!p snip.rv=qwrap(t[2])`);

	add_prop(ROOM_I_INSIDE, ${3:1});
	add_prop(ROOM_I_LIGHT, ${4:2});
	add_prop(ROOM_I_TYPE, ROOM_${5:NORMAL});

	add_prop(ROOM_I_NO_ALLOW_STEED, ${6:1});
	add_prop(ROOM_M_NO_ATTACK, ${7:"The feeling of peace is too great here.\n"});

	add_exit("${8:/path/to/chapel/exit}", 
			"${9:out}", "${10:VBFC}");

	add_npc("${11:/path/to/cleric}", ${12:1}, ${13:&->equip_me()});
}

/*
 * Function name: gs_hook_start_meditating
 * Description	: describe meditation experience
 */
void
gs_hook_start_meditating()
{
	/*-{
		Description: 
					${14:You kneel before the altar of Paladine and close your eyes. A 
					feeling of great ease and self control falls upon you. You block 
					of your senses and concentrate solely upon your own mind. You 
					feel Paladine with you and he gives you the power to <estimate> 
					your different stats and <set> the learning preferences at your 
					own desire. Just <rise> when you are done meditating.}
	}-*/
	write(`!p snip.rv=qwrap(t[14])`);
	say(QCTNAME(this_player()) + "${15: kneels down before the altar.}\n");
}

/*
 * Function name: gs_hook_rise
 * Description	: $1
 */
int
gs_hook_rise()
{
	/*-{
		Description: 
					${16:As if ascending from a great depth, you rise to the surface of 
					your consciousness. You exhale and feel very relaxed as you get 
					up and leave the altar.}
	}-*/
	write(`!p snip.rv=qwrap(t[16])`);
	say(QCTNAME(this_player()) + "${17: rises from the altar.}\n");
}

/*
 * Function name: init
 * Description:   Initalize the chapel actions
 */
void
init()
{
	::init();
	init_guild_support();
}
endsnippet

post_jump "clean_description()"
snippet create_shop "Create a shop" b
/*
 * Function name: create_room
 * Description	: $1
 */
void
create_room()
{
	set_short("${1:The Trading Outpost}");

	/*-{
		Description: 
					${2:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[2])`);

	add_item("${3:counter}", "${4:It is a wooden counter.}\n");

	add_item( ({ ${5:"door", "doors"} }),
		"${6:The doors are made of the same wood as the rest of the "
		+ "cabinet. They are secured with iron bands and closed shut!}\n");

	add_cmd_item( ({ ${7:"cabinet", "door", "doors"} }),
		({ ${8:"open", "enter", "unlock"} }),
		"${9:The doors of the cabinet are closed and fermly locked. There "
		+ "is no way you can open the doors so do not even think about "
		+ "entering the cabinet.}\n");

	add_prop(ROOM_I_INSIDE, ${10:1});
	add_prop(ROOM_I_LIGHT, ${11:1});
	add_prop(ROOM_I_TYPE, ROOM_${12:NORMAL});

	add_prop(ROOM_I_NO_ALLOW_STEED, ${13:1});
	add_prop(ROOM_M_NO_ATTACK, ${14:0});

	add_exit("${15:/path/to/storeroom}", "${16:storeroom}", 0);

	add_exit("${17:/path/to/shop/exit}", 
			"${18:out}", "${19:VBFC}");

	add_npc("${20:/path/to/merchant}", ${21:1}, ${22:&->equip_me()});

	config_default_trade();
	set_money_give_max(1000);
	set_store_room(${23:/path/to/storeroom});
}

/*
 * Function name: init
 * Description:   Initalize the shop actions
 */
void
init()
{
	::init();
	init_shop();
}
endsnippet

post_jump "clean_description()"
snippet create_storeroom "Create a store room" b
/*
 * Function name: create_room
 * Description	: $1
 */
void
create_room() 
{
	set_short("${1:Storeroom of the shop}");

	/*-{
		Description: 
					${2:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[2])`);

	add_prop(ROOM_I_INSIDE, ${3:1});
	add_prop(ROOM_I_LIGHT, ${4:1});
	add_prop(ROOM_I_TYPE, ROOM_${5:NORMAL});

	add_prop(ROOM_I_NO_ALLOW_STEED, ${6:0});
	add_prop(ROOM_M_NO_ATTACK, ${7:0});

	add_exit("${8:/path/to/storeroom/exit}", "${9:out}");

	set_default_stock(({ 
		"${10:/path/to/item1}", ${11:1 - item1_qty}, 
		"${12:/path/to/item2}", ${13:4 - item2_qty}, 
	}));
	reset_store();
}

/*
 * Function name: enter_inv
 * Description  : You should always call store_update() if an object enters 
 *                the storeroom to update it and let it be added to the stock
 */
void
enter_inv(object obj, object from)
{
	::enter_inv(obj, from);
	store_update(obj);
}

/*
 * Function name: reset_room
 * Description  : To have the default stock replenished at reset, 
 *                define the function reset_room() to call reset_store()
 */
void
reset_room()
{
	reset_store();
}
endsnippet

post_jump "clean_description()"
snippet create_training "Create a training room" b
void set_up_skills();

/*
 * Function name: create_room
 * Description	: $1
 */
void
create_room()
{ 
	set_short("${1:The Training Room}");

	/*-{
		Description: 
					${2:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[2])`);

	add_item("sign", "");
	add_cmd_item(({"words", "sign"}), "read", "@@read");

	add_item("${3:sign}", "${4:There are words on it, why not read it?}\n");

	add_cmd_item( ({ ${5:"words", "sign"} }), ({ ${6:"read"} }), "${7:"@@read"});

	add_prop(ROOM_I_INSIDE, ${8:1});
	add_prop(ROOM_I_LIGHT, ${9:1});
	add_prop(ROOM_I_TYPE, ROOM_${10:NORMAL});

	add_prop(ROOM_I_NO_ALLOW_STEED, ${11:1});
	add_prop(ROOM_M_NO_ATTACK, ${12:0});

	add_exit("${13:/path/to/storeroom}", "${14:storeroom}", 0);

	add_exit("${15:/path/to/training/room/exit}", 
			"${16:out}", "${17:VBFC}");

	add_npc("${18:/path/to/trainer}", ${19:1}, ${20:&->equip_me()});

	create_skill_raise();
	set_up_skills();
}

/*
 * Function name: read
 * Description:   read the training instructions
 */
int
read()
{

	/*-{
		Description: 
					${21:In here you can train rescueing, kicking and bashing skills. To
					use them you do the commands 'rescue', 'ckick' or 'bash'. If you
					rescue another being one of the living beings hitting on this
					being will start hitting on you instead. 'ckick' stands for
					combat kick, and if it's successful you will hurt your opponent.
					You will have to wait a little between each kick. A bash works
					just as a kick, but it hits harder and you have to wait a little
					longer between each bash.
					When you improve your skills here you will advance much quicker
					than you do in normal guilds. And if you are intelligent you will
					learn even quicker.}
	}-*/
	write(`!p snip.rv=qwrap(t[21])`);

	return 1;
}

/*
 * Function name: init
 * Description:   Initalize the skill training actions
 */
void
init()
{
	init_skill_raise();
	::init();
}

void
set_up_skills()
{
	sk_add_train(SS_${22:RESCUE}, "${23:rescue people when fighting}", "${24:rescue}", ${25:50}, ${26:100} );
	sk_add_train(SS_${27:BASH}, "${28:bash an enemy}", "${29:bash}", ${30:100}, ${31:100} );
}
endsnippet
# }}}


#
# Generic: object
# {{{
post_jump "clean_description()"
snippet create_object "Create an object" b
/*
 * Function name: create_object
 * Description  : $5
 */
void
create_object()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	add_prop(OBJ_I_WEIGHT, ${11:Weight [g]});
	add_prop(OBJ_I_VOLUME, ${12:Volume [ml]});
	add_prop(OBJ_I_VALUE, ${13:Value [cc]});
}
endsnippet
# }}}


#
# Armours and wearables
# {{{
post_jump "clean_description()"
snippet create_armour "Create an armour" b
/*
 * Function name: create_armour
 * Description	: $5, recoverable: ${7:(Yes/No)}
 */
void
create_armour()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	set_ac(${9:0-40});
	set_at(A_${10:BODY});

	set_am(({ ${11:Impale:<3}, ${12:Slash:<3}, ${13:Bludgeon:<3} }));

	set_likely_break(${14:0-20});

	add_prop(OBJ_I_WEIGHT, ${15:F_WEIGHT_DEFAULT_ARMOUR($9, A_$10)});
	add_prop(OBJ_I_VOLUME, ${16:F_WEIGHT_DEFAULT_ARMOUR($9, A_$10)/5});
	add_prop(OBJ_I_VALUE, ${17:F_VALUE_ARMOUR(A_$10)});
}
${7/^([Yy]es)|(.*)$/(?1:
\/*
 * Function name\: query_recover
 * Description	\: Save armour state
 *\/
void
query_recover()
{
	return MASTER + "\:" + query_arm_recover();
}

\/*
 * Function name\: init_recover
 * Description	\: Restore armour state
 *\/
void
init_recover(string arg)
{
	init_arm_recover(arg);
}
:)/}
$0
endsnippet

snippet create_wearable "Create wearable item" b
/*
 * Function name: create_object
 * Description	: $5, recoverable: ${7:(Yes/No)}
 */
public nomask void
create_object()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/* 
		Description: 
					${8:Long description}
	*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	set_slots(A_${9:HEAD});

	set_layers(${10:2, layers it occupies});
	set_looseness(${11:3, layers it can be worn on});

	add_prop(OBJ_I_WEIGHT, ${12:light});
	add_prop(OBJ_I_VOLUME, ${13:foldable});
	add_prop(OBJ_I_VALUE,	${14:fairly inexpensive});
}

/*
 * Description: We need to override leave_env() so that we can 
 *		be sure to remove the $1 if it gets moved from 
 *		the wearer while it is still worn.
 */
public void
leave_env(object env, object to)
{
	::leave_env(env, to);

	wearable_item_leave_env(env, to);
}

/*
 * Description: We need to override appraise_object() so that we can 
 *		be sure that the player can appraise it properly.
 */
void
appraise_object(int num)
{
	::appraise_object(num);

	appraise_wearable_item();
}
${7/^([Yy]es)|(.*)$/(?1:
\/*
 * Function name\: query_recover
 * Description	\: Save armour state
 *\/
void
query_recover()
{
	return MASTER + "\:";
}
:)/}
$0
endsnippet

snippet create_magical_armour "Create magical armour" b
/*
 * Function name: create_armour
 * Description	: $5, magical, recoverable: ${7:(Yes/No)}
 */
void
create_armour()
{
	add_prop(OBJ_I_IS_MAGIC_ARMOUR, 1);

	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	add_item(({ ${9:Detail} }), 
			"${10:Detail to suggest magical nature of armour.}\n");

	set_ac(${11:0-60});
	set_at(A_${12:BODY});

	set_am(({ ${13:Impale:<4}, ${14:Slash:<4}, ${15:Bludgeon:<4} }));

	set_likely_break(${16:0-20});

	add_prop(OBJ_I_WEIGHT, ${17:F_WEIGHT_DEFAULT_ARMOUR($11, A_$12)});
	add_prop(OBJ_I_VOLUME, ${18:F_WEIGHT_DEFAULT_ARMOUR($11, A_$12)/5});
	add_prop(OBJ_I_VALUE, ${19:F_VALUE_ARMOUR(A_$12)}*2 + 1000); 

	set_af(this_object());

	set_keep(1);
${11/^([456][0-9])|(.*)$/(?1:
	add_prop(OBJ_M_NO_BUY, 
		"Merchant nervously declines to buy so valuable item.}");
:)/}
	// The 'form' of the magic and the degree of its expression.
	add_prop(MAGIC_AM_MAGIC, ({ ${20:40}, "${21:enchantment}" }));

	add_prop(MAGIC_AM_ID_INFO, ({
	"${22:Identify 1 description. }", 10,		
	"${23:Identify 2 description. }", 30,
	"${24:Identify 3 description. }", 50}));

	add_prop(OBJ_S_WIZINFO,
		"${25:Wizard description, include all magical effects, spawn "+
		"location and monsters that own this armour.}\n");
}

varargs mixed
query_magic_protection(string prop, object protectee = previous_object())
{
	if (query_prop(OBJ_I_IS_MAGIC_ARMOUR) && (protectee == query_worn()))
	{
	if (prop == MAGIC_I_RES_${26:FIRE})
		return ({ ${27:Strength(%):<40add/<75abs}, ${28:Additive:1/Absolute:0} }); 
	else
	{
		return ::query_magic_protection(prop, protectee);
	}
}

mixed
wear(object ob)
{
	if (!query_prop(OBJ_I_IS_MAGIC_ARMOUR))
		return 0;

	if (wearer->resolve_task(TASK_${29:DIFFICULT}, ({TS_${30:DIS}, SS_${31:AWARENESS} })) < 0)
	{
		return "${32:Armour resists wearer, describe the effect.}\n";
	}

	wearer->add_magic_effect(this_object());

	wearer->catch_tell("${33:Describe effect of wearing the armour.}\n");

	return 0;
}

mixed
remove(object ob)
{
	wearer->remove_magic_effect(this_object());

	if (query_prop(OBJ_I_IS_MAGIC_ARMOUR))
		wearer->catch_tell("${34:Describe effect of armour removal.}\n");

	return 0;
}


public int
disenchant_object(object disenchanter)
{
	remove_prop(OBJ_I_IS_MAGIC_ARMOUR);
	remove_prop(MAGIC_AM_MAGIC);
	add_prop(MAGIC_AM_ID_INFO, ({ 
		"${35:This item once possessed some magical power, but it is " +
		"now gone.}\n", 50 }));

	add_prop(OBJ_I_VALUE, F_VALUE_ARMOUR($11)); 

	remove_prop(OBJ_M_NO_BUY);

	if (query_worn())
		wearer->remove_magic_effect(this_object());

	tell_room(environment(this_object()), 
			  "${36:Describe effect of disenchanting for everyone in room.}\n");

	remove_item(${9/^[^"]*("[^"]*").*$/$1/});
	add_item(({ $9 }), 
		"${36:Describe disenchanted magical armour detail.}\n");

	return 1;
}
${7/^([Yy]es)|(.*)$/(?1:
\/*
 * Function name\: query_recover
 * Description	\: Save armour state
 *\/
void
query_recover()
{
	return MASTER + "\:" + query_arm_recover();
}

\/*
 * Function name\: init_recover
 * Description	\: Restore armour state
 *\/
void
init_recover(string arg)
{
	init_arm_recover(arg);
}
:)/}
$0
endsnippet
# }}}

#
# Weapons
# {{{
post_jump "clean_description()"
snippet create_weapon "Create a weapon" b
/*
 * Function name: create_weapon
 * Description	: $5, recoverable: ${7:(Yes/No)}
 */
void
create_weapon()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	set_hit(${9:0-40});
	set_pen(${10:0-40});

	set_wt(W_${11:KNIFE});
	set_dt(W_${12:SLASH} | W_${13:IMPALE});

	set_hands(W_${14:ANYH});

	add_prop(OBJ_I_WEIGHT, ${16:F_WEIGHT_DEFAULT_WEAPON($9, $10)});
	add_prop(OBJ_I_VOLUME, ${17:F_WEIGHT_DEFAULT_WEAPON($9, $10)/5});
	add_prop(OBJ_I_VALUE, ${18:F_VALUE_WEAPON($9, $10)});
}
${7/^([Yy]es)|(.*)$/(?1:
\/*
 * Function name\: query_recover
 * Description	\: Save weapon state
 *\/
void
query_recover()
{
	return MASTER + "\:" + query_wep_recover();
}

\/*
 * Function name\: init_recover
 * Description	\: Restore weapon state
 *\/
void
init_recover(string arg)
{
	init_wep_recover(arg);
}
:)/}
$0
endsnippet

post_jump "clean_description()"
snippet create_bow "Create a bow" b
/*
 * Function name: create_bow
 * Description	: $5 bow, recoverable: ${6:(Yes/No)}
 */
void
create_bow()
{
	set_adj("${1:first adjective}");
	add_adj("${2:second adjective}");

	set_short("${3:$2 $1 bow}");
	set_pshort("${4:$2 bows}");

	/*-{
		Description: 
					${5:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[5])`);

	set_hit(${7:0-40});
	set_pen(${8:0-40});

	add_prop(OBJ_I_WEIGHT, ${9:900});
	add_prop(OBJ_I_VOLUME, ${10:3000});
	add_prop(OBJ_I_VALUE, ${11:F_VALUE_WEAPON($9, $10)});
}
${7/^([Yy]es)|(.*)$/(?1:
\/*
 * Function name\: query_recover
 * Description	\: Save weapon state
 *\/
void
query_recover()
{
	return MASTER + "\:" + query_wep_recover();
}

\/*
 * Function name\: init_recover
 * Description	\: Restore weapon state
 *\/
void
init_recover(string arg)
{
	init_wep_recover(arg);
}
:)/}
$0
endsnippet

post_jump "clean_description()"
snippet create_arrow "Create an arrow" b
/*
 * Function name: create_arrow
 * Description	: $1 $2 arrow, recoverable: ${6:(Yes/No)}
 */
void
create_arrow()
{
	set_adj("${1:first adjective}");
	add_adj("${2:second adjective}");

    set_projectile_id("${3:$1_$2_arrow}");

	/*-{
		Description: 
					${5:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[5])`);

	set_hit(${7:0-40});
	set_pen(${8:0-40});
}

/*
 * Function name: get_projectile_long
 * Description	: detailed arrow description
 */
string
get_projectile_long(string str, object for_obj, int num)
{
    return ${9:((num == 1) ? "This arrow is" : "These arrows are") + 
      " obviously of good making. Well balanced, straight and with " + 
      "fins made from feathers that gleam in a spectrum of colours. " + 
      "Tipped with " + ((num == 1) ? "a head" : "heads") +
      " of blue tempered steel the " + ((num == 1) ? "arrow" : "arrows") +
      " look both graceful and beautiful, but above all else; lethal.\n"};
}

${7/^([Yy]es)|(.*)$/(?1:
\/*
 * Function name\: query_recover
 * Description	\: Save weapon state
 *\/
void
query_recover()
{
	return MASTER + "\:" + query_wep_recover();
}

\/*
 * Function name\: init_recover
 * Description	\: Restore weapon state
 *\/
void
init_recover(string arg)
{
	init_wep_recover(arg);
}
:)/}
$0
endsnippet

post_jump "clean_description()"
snippet create_magical_weapon "Create magical weapon" b
/*
 * Function name: create_weapon
 * Description	: $5, magical, recoverable: ${7:(Yes/No)}
 */
void
create_weapon()
{
	add_prop(OBJ_I_IS_MAGIC_WEAPON, 1);

	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	add_item(({ ${9:Detail} }), 
			"${10:Detail to suggest magical nature of weapon.}\n");

	set_hit(${11:0-60});
	set_pen(${12:0-60});

	add_prop(OBJ_I_WEIGHT, ${17:F_WEIGHT_DEFAULT_WEAPON($11, $12)});
	add_prop(OBJ_I_VOLUME, ${18:F_WEIGHT_DEFAULT_WEAPON($11, $12)/5});
	add_prop(OBJ_I_VALUE, ${19:F_VALUE_WEAPON($11, $12)}*2 + 1000); 

	set_wf(this_object());

	set_keep(1);

	add_prop(OBJ_M_NO_BUY, 
		"${20:Merchant nervously declines to buy so valuable item.}");

	// The 'form' of the magic and the degree of its expression.
	add_prop(MAGIC_AM_MAGIC, ({ ${21:Intensity(%):50}, "${22:enchantment}" }));

	add_prop(MAGIC_AM_ID_INFO, ({
	"${23:Identify 1 description. }", 10,		
	"${24:Identify 2 description. }", 30,
	"${25:Identify 3 description. }", 50}));

	add_prop(OBJ_S_WIZINFO,
		"${26:Wizard description, include all magical effects, spawn "+
		"location and monsters that own this weapon.}\n");
}

/*
 * Function name: wield
 * Description:   Sets up a nice wield sequence for the players.
 * Arguments:     wep -  the weapon the command is performed upon
 * Returns:       1 if wielded, 0 otherwise
 */
mixed
wield(object ob)
{
	if (!query_prop(OBJ_I_IS_MAGIC_ARMOUR))
		return 0;

	if (wielder->resolve_task(TASK_${29:DIFFICULT}, ({TS_${30:WIS}, SS_${31:_WEP_SWORD} })) < 0)
	{
		return "${32:Weapon resists wielder, describe the effect.}\n";
	}

	wielder->add_magic_effect(this_object());

	wielder->catch_tell("${33:Describe effect of wielding the weapon.}\n");

	return 0;
}

/*
 * Function name: unwield
 * Description:   Sets up a unwield sequence for the players.
 *				  (Not really needed here?)
 * Arguments:	  wep -  the weapon the command is performed upon
 * Returns:		  0 if unwielded, 1 unwield but no message
 *				  -1 do not unwield, print normal message
 */
mixed
unwield(object ob)
{
	wielder->remove_magic_effect(this_object());

	if (query_prop(OBJ_I_IS_MAGIC_WEAPON))
		wielder->catch_tell("${34:Describe effect of wepon removal.}\n");

	return 0;
}

/*
 * Function name: did_hit 
 * Description	: Called whenever the weapon is used.  
 *				  Redefine it to do extra damage.
 */
public varargs int
did_hit(int aid, string hdesc, int phurt, object enemy, int dt,
				int phit, int dam)
{
	int resistance;
	object attacker = query_wielded();

	// Check for miss (did_hit is called in case of miss too)
	if (phurt < 0)
	{
		return ::did_hit(aid, hdesc, phurt, enemy, dt, phit, dam);
	}

	if (${35:Hit condition, ie race or !random(10)})
	{
		attacker->catch_tell("${36:Describe effect for attacker.}\n");
		enemy->catch_tell("${37:Describe effect for enemy.}\n");
		enemy->tell_watcher(${38:Describe effect for everyone else.}, attacker);

		// Ensure that magic resistance is taken into account
		resistance = spell_resist_basic(this_object(), enemy, SS_ELEMENT_${39:DEATH},
			TASK_${40:DIFFICULT});

		// Do the extra damage, taking the magic resistance into account
		enemy->hit_me(${41:Base damage, ie 200} * (100 - resistance) / 100, 
					MAGIC_DT, attacker, -1);

		// Kill the target, if appropriate
		if (enemy->query_hp() <= 0)
		{
			enemy->do_die(attacker);
		}
	}

	return ::did_hit(aid, hdesc, phurt, enemy, dt, phit, dam);
}

public int
disenchant_object(object disenchanter)
{
	remove_prop(OBJ_I_IS_MAGIC_WEAPON);
	remove_prop(MAGIC_AM_MAGIC);
	add_prop(MAGIC_AM_ID_INFO, ({ 
		"${42:This item once possessed some magical power, but it is " +
		"now gone.}\n", 50 }));

	add_prop(OBJ_I_VALUE, F_VALUE_WEAPON($11, $12)); 

	remove_prop(OBJ_M_NO_BUY);

	if (query_worn())
		wearer->remove_magic_effect(this_object());

	tell_room(environment(this_object()), 
			"${43:Describe effect of disenchanting for everyone in room.}\n");

	remove_item(${9/^[^"]*("[^"]*").*$/$1/});
	add_item(({ $9 }), 
		"${36:Describe disenchanted magical weapon detail.}\n");

	return 1;
}
${7/^([Yy]es)|(.*)$/(?1:
\/*
 * Function name\: query_recover
 * Description	\: Save armour state
 *\/
void
query_recover()
{
	return MASTER + "\:" + query_arm_recover();
}

\/*
 * Function name\: init_recover
 * Description	\: Restore armour state
 *\/
void
init_recover(string arg)
{
	init_arm_recover(arg);
}
:)/}
$0
endsnippet

post_jump "clean_description()"
snippet create_poison_weapon "Create a poison weapon" b
static int poison_used;

/*
 * Function name: create_weapon
 * Description	: $5, poison weapon, recoverable
 */
void
create_weapon()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	set_hit(${9:0-40});
	set_pen(${10:0-40});

	set_wt(W_${11:KNIFE});
	set_dt(W_${12:SLASH} | W_${13:IMPALE});

	set_hands(W_${14:ANYH});

	poison_used = 0;

	add_prop(OBJ_I_WEIGHT, ${16:F_WEIGHT_DEFAULT_WEAPON($9, $10)});
	add_prop(OBJ_I_VOLUME, ${17:F_WEIGHT_DEFAULT_WEAPON($9, $10)/5});
	add_prop(OBJ_I_VALUE, ${18:F_VALUE_WEAPON($9, $10)});
}

/*
 * Function name: remove_poison
 * Description:   Call this to remove the poison from the blade
 */
void
remove_poison()
{
	poison_used = 1;
	set_long("${19:Change weapon description to make it look "
	       + "look like ordinary weapon.}\n");
}

public varargs int
did_hit(int aid, string hdesc, int phurt, object enemy, int dt, int phit,
	int dam)
{
	object poison;

	if (!poison_used && phurt > 0${20: && !random(5)})
	{
		setuid();
		seteuid(getuid());

		poison = clone_object(POISON_OBJECT);
		if(${21:When poison wears off, rand/charges?})
		{
			remove_poison();
		}

		poison->move(enemy);
		poison->set_time(${22:Poison duration, ie 500});
		poison->set_interval(${23:Poison interval, ie 60});
		poison->set_strength(${24:Poison strength, ie 40});
		poison->set_damage(({POISON_${25:MANA}, ${26:100}, POISON_${27:STAT}, SS_${28:INT}}));
		poison->start_poison(query_wielded());
	}

	return ::did_hit(aid, hdesc, phurt, enemy, dt, phit, dam);
}

string
query_recover()
{
	return ::query_recover() + "PUSED:" + poison_used;
}

void
init_recover(string arg)
{
	string str;

	sscanf(arg, "%sPUSED:%d", str, poison_used);

	if (poison_used)
	{
		remove_poison();
	}

	::init_recover(arg);
}
$0
endsnippet

# }}}

#
# Containers (bags, backpacks, etc)
# {{{
post_jump "clean_description()"
snippet create_backpack "Create a backpack" b
/*
 * Function name: create_pack
 * Description  : Standard genesis backpack
 */
void
create_pack()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	set_mass_storage(1); 

	set_keep(1); 

	add_prop(CONT_I_WEIGHT, ${9:4500});
	add_prop(CONT_I_MAX_WEIGHT, ${10:150000});
	add_prop(CONT_I_VOLUME, ${11:8000});
	add_prop(CONT_I_MAX_VOLUME, ${12:150000});

	add_prop(OBJ_I_VALUE, ${13:450});
}
endsnippet

post_jump "clean_description()"
snippet create_bag "Create a bag" b
/*
 * Function name: create_container
 * Description  : Recepticle
 */
void
create_container()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	set_keep(1); 

	add_prop(CONT_I_WEIGHT, ${9:4500});
	add_prop(CONT_I_MAX_WEIGHT, ${10:150000});
	add_prop(CONT_I_VOLUME, ${11:8000});
	add_prop(CONT_I_MAX_VOLUME, ${12:150000});

	add_prop(OBJ_I_VALUE, ${13:450});
}
endsnippet

post_jump "clean_description()"
snippet create_chest "Create a chest" b
/*
 * Function name: create_container
 * Description  : Create a chest
 */
void
create_container()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);


	add_prop(CONT_I_WEIGHT, ${9:9500});
	add_prop(CONT_I_MAX_WEIGHT, ${10:250000});
	add_prop(CONT_I_VOLUME, ${11:8000});
	add_prop(CONT_I_MAX_VOLUME, ${12:150000});

	add_prop(CONT_I_RIGID, 1);
	add_prop(CONT_I_CLOSED, 1);

	add_prop(OBJ_I_VALUE, ${13:480});

	set_key("${14:CHEST_KEY_ID}");
}
endsnippet

post_jump "clean_description()"
snippet create_trapped_chest "Create a trapped chest" b
/*
 * Function name: create_container
 * Description  : Recepticle
 */
void
create_container()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`
			 + "@@trap_desc@@");


	add_prop(CONT_I_WEIGHT, ${9:9500});
	add_prop(CONT_I_MAX_WEIGHT, ${10:250000});
	add_prop(CONT_I_VOLUME, ${11:8000});
	add_prop(CONT_I_MAX_VOLUME, ${12:150000});

	add_prop(CONT_I_RIGID, 1);
	add_prop(CONT_I_CLOSED, 1);

	add_prop(OBJ_I_VALUE, ${13:480});

	set_cf(this_object());

	set_key("${14:CHEST_KEY_ID}");
}

/*
 * Function name: spring trap
 * Description:   This function is called when the trap is sprung.
 * Arguments:	  object who - the person who sprung the trap
 */
public void
spring_trap(object who)
{
	if (!query_trapped())
	{
		return;
	}

	who->catch_tell("${15:A small razor sharp blade slashes "+
		"your hand as you " + query_verb() + " the chest!}\n");
	who->heal_hp(-(${16:90 + random(100)}));

	if (who->query_hp() < 1)
	{
	who->do_die(this_object());
	}

	set_trapped(0);
}

/*
 * Function name: open
 * Description:   This is called when the chest is opened.	We use it to
 *				  spring the trap when that happens.
 */
public mixed
open(object ob)
{
	spring_trap(this_player());

	return 0;
}

/*
 * Function name: pick_fail
 * Description:   This is called when someone tries to pick the 
 *				  lock, but fails.	We want to spring the trap
 *				  if that happens.
 * Arguments:	  object who - the person that attempted to pick the lock
 *				  int skill  - how well the well (badly) the lock was picked 
 */
public void
pick_fail(object who, int skill)
{
	spring_trap(who);
}

public void
init()
{
	::init();
	init_trap();
}
endsnippet

# }}}

#
# Food and drinks
# {{{
post_jump "clean_description()"
snippet create_food "Create food" b
/*
 * Function name: create_food
 * Description  : $5, food
 */
void
create_food()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	set_amount(${9:Nutritional value[g], ie 50}); 

	add_prop(CONT_I_WEIGHT, ${10:$9});
	add_prop(CONT_I_VOLUME, ${12:30});
}
endsnippet

post_jump "clean_description()"
snippet create_drink "Create drink" b
/*
 * Function name: create_drink
 * Description  : $5, drink
 */
void
create_drink()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	set_soft_amount(${9:Soft drink amount[ml], ie 330}); 
	set_alco_amount(${10:Alcohol[ml], ie 16}); 

	add_prop(CONT_I_WEIGHT, ${11:`!p snip.rv=str(int(t[9])+int(t[10])`});
	add_prop(CONT_I_VOLUME, ${12:346});
}
endsnippet

# }}}

#
# Gem
# {{{
post_jump "clean_description()"
snippet create_gem "Create gem" b
/*
 * Function name: create_object
 * Description  : $5
 */
void
create_object()
{
	set_name("${1:gem}");
	set_pname("${2:gems}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	add_prop(OBJ_I_VALUE, ${11:100});
}
endsnippet
# }}}

#
# Rope
# {{{
post_jump "clean_description()"
snippet create_rope "Create rope" b
/*
 * Function name: create_rope
 * Description  : $5
 */
void
create_rope()
{
	set_name("${1:rope}");
	set_pname("${2:ropes}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);
}
endsnippet
# }}}

#
# Message (for messengers)
# {{{
snippet create_message "Create message" b
/*
 * Function:    create_message
 * Description: Default create method for a message object. All we
 *              do here is customize the short description.
 */
public void
create_message()
{
	set_short("${1:"message from " + query_sender()}.\n");
}

/*
 * Function:	message_description
 * Description: This function is what the message looks like when it is
 *				"read" or "examine"d. Mask this function to customize
 *				the presentation to the player.
 * Returns:		string to be displayed
 */
public string
message_description()
{
	return ${2:"The message from " + query_sender() + " reads:\n" +
			query_message() + "\n"};
}

/*
 * Function:	hook_message_destroyed
 * Description: Hook method that gets called when a message is destroyed.
 *				Mask this function to customize the message that players
 *				will see.
 * Arguments:	room   - room that the message is in
 *				player - if not null, then this is the player that dropped
 *						 the message, causing it to be destroyed.
 */
public varargs void
hook_message_destroyed(object room, object player)
{
	tell_room(room, ${3:"The " + short() + " crumbles to dust, then blows away.\n"});
}
endsnippet
# }}}

#
# Torch (or any other light source like lamp, candle, etc)
# {{{
post_jump "clean_description()"
snippet create_torch "Create torch" b
/*
 * Function:    create_torch
 * Description: $5
 */
void
create_torch()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	set_strength(${9:2 - light strength});
	set_timeout(${10:120 - timeout in seconds});

	add_prop(OBJ_I_WEIGHT, ${11:1500});
	add_prop(OBJ_I_VOLUME, ${12:500});
	add_prop(OBJ_I_VALUE, ${13:5184});

	set_keep(1);
}

string
query_recover()
{
	return MASTER + ":" + query_torch_recover();
}

void
init_recover(string arg)
{
	init_torch_recover(arg);
}
endsnippet
# }}}

#
# Holdable item
# {{{
post_jump "clean_description()"
snippet create_holdable "Create holdable item" b
/*
 * Function:    create_object
 * Description: $5
 */
public void
create_object()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${3:first adjective}");
	add_adj("${4:second adjective}");

	set_short("${5:$4 $3 $1}");
	set_pshort("${6:$4 $2}");

	/*-{
		Description: 
					${8:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[8])`);

	add_item(({ ${9:Detail} }), 
			"${10:Detail to suggest magical nature of the item.}\n");

	add_prop(OBJ_I_WEIGHT, ${11:1500});
	add_prop(OBJ_I_VOLUME, ${12:500});
	add_prop(OBJ_I_VALUE, ${13:5184});

	set_keep(1);

	add_prop(OBJ_M_NO_BUY, 
		"Merchant nervously declines to buy so valuable item.");
	
	add_prop(MAGIC_AM_MAGIC, ({ ${14:Intensity(%):30}, "${15:enchantment}" }));

	add_prop(MAGIC_AM_ID_INFO, ({
	"${16:Identify 1 description. }", 10,		
	"${17:Identify 2 description. }", 30,
	"${18:Identify 3 description. }", 50}));

	add_prop(OBJ_S_WIZINFO,
		"${19:Wizard description, include all magical effects, spawn "+
		"location and monsters that own this item.}\n");

	set_slots(W_${20:ANYH});
}

/*
 * Function name: hold
 * Description:   This function is called to see if the item can be held.
 * Returns:		  see /lib/holdable_item.c:hold
 */
public mixed
hold()
{
	int able_to_hold_item = 1;

	// Test if able to hold the item
	$0
	if (able_to_hold_item)
	{
		write("As you hold the " + short() + " in your hand, " +
			"a strange warmth pervades your body.\n");

		// Add magic effect to holder

		return 1;
	}

	write("You feel the " + short() + " resist your grasp.\n");
	return -1;
}

/*
 * Function name: release
 * Description:   This function is called to see if the item can be released.
 * Returns:		  see /lib/holdable_item.c:release
 */
public mixed
release()
{
	int able_to_release = 0;

	// Remove magic effect from holder

	return able_to_release;
}

/* Function name: leave_env
 * Description:   This function is called when the item moves from
 *				  one environment to another.
 * Arguments:	  object env - the environment being left
 *				  object to  - the environment being entered
 */
public void
leave_env(object env, object to)
{
	::leave_env(env, to);
	holdable_item_leave_env(env, to);
}

/*
 * Function name: appraise_object
 * Description:   This is called when someone appraises this item.
 *				  We want to mask it to add a message telling the
 *				  appraiser that the item can be held.
 */
public void
appraise_object(int num)
{
	::appraise_object(num);
	appraise_holdable_item();
}
endsnippet
# }}}

#
# Herbs and potions (they work almost the same)
# {{{
# }}}

#
# Scrolls (books/magic scrolls/magic tomes)
# {{{
# }}}

#
# NPCs (humanoids, creatures, messengers)
# {{{
post_jump "clean_description()"
snippet create_npc "Create a npc" b
/*
 * Function:	create_monster
 * Description: $5
 */
create_monster()
{
	set_name("${1:name}");

	set_adj("${2:first adjective}");
	add_adj("${3:second adjective}");
	set_race_name("${4:race}");

	set_short("${5:$3 $2 $4}");

	/*-{
		Description: 
					${6:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[6])`);

	set_gender(G_${7:MALE});
	set_alignment(${8:0, between -1200 and 1200});

	set_title("${9:Title for introductions}");

	${10:set_living_name("${11:_$1_$4_uniq_}");
	}
	set_hp(query_max_hp());

	add_prop(CONT_I_HEIGHT, ${12:height [cm]});
	add_prop(CONT_I_WEIGHT, ${13:weight [g]});
	add_prop(CONT_I_VOLUME, ${14:volume w/o inventory [ml]});

	add_prop(LIVE_I_NO_BODY, ${15:0});
	add_prop(LIVE_I_UNDEAD, ${16:0, [0-100 max] - turning resistance});
	add_prop(LIVE_I_NEVERKNOWN, ${17:0});
	${18:remove_prop(LIVE_M_NO_ACCEPT_GIVE);
	}
	${19:set_aggressive(1);
	}
	set_stats(({ ${20:STR [0-250]}, ${21:DEX}, ${22:CON}, ${23:INT}, ${24:WIS}, ${25:DIS} }), ${26:deviation [0-50%]});

	set_skill(SS_${27:WEP_SWORD}, ${28:85 [0-100]}); 
	set_skill(SS_${29:UNARM_COMBAT}, ${30:55}); 
	set_skill(SS_${31:DEFENCE}, ${32:65}); 
	set_skill(SS_${33:AWARENESS}, ${34:60}); 
	set_skill(SS_${35:BLIND_COMBAT}, ${36:60}); 
	set_skill(SS_${37:LOC_SENSE}, ${38:45}); 
	${39:
	// Unarmed combat buffs
	set_all_hitloc_unarmed(${40:armour});
	set_all_attack_unarmed(${41:hit}, ${42:pen});
	}

	set_default_answer("${43:The Goblin says: I don't know what you are talking " +
		"about.}\n");

	set_chat_time(${44:5});
	${45:add_chat("Hi, how are you?");
	add_chat("I'm talking to you ;-)");
	add_chat("Don't you think this is fun?");
	}

	set_act_time(${46:5});
	${47:add_act("laugh");
	add_act(({"say I'm good you know.", "wink", "applaud"}));}

	set_cact_time(${48:2}); 
	${49:add_cact("scowl savagely"); 
	add_cact("swear"); 
	add_cact("say No-one gets away with that!");}

	${50:add_ask(({"weather", "time"}), "The goblin frowns: I don't care about " +
		"weather nor time.\n");}

	add_prop(LIVE_I_NO_CORPSE, ${51:0});
	${52:
	add_leftover("${53:/std/leftover}", "${54:organ}", ${55:# items on body}, ${56:vbfc to check on tear/cut or 0}, ${57:0/1 hard remains? (left after decay)}, ${58:1/0 cut/tear}, ${59:weight [corpse/1000 pts]});
	}

	equip(({ ARMOUR_DIR + "${60:mail}", WEAPON_DIR + "${61:sword}" }));

	${62:
	// Movement
	set_random_move(10);}
}

${63:/* 
 * Function:    special_attack
 * Description: special_attack() is called by the standard combat
 * Arguments:   object enemy - target
 * Returns:     0/1 - round continues or it is done (prevent plain attack)
 */ 
int
special_attack(object enemy)
{
	int result, stun_duration; 
	string impact, reaction, onlooker_reaction; 

	  // Only execute the special attack 1 in 8 rounds on average 
	if (random(8)) 
		return 0;  // Combat round continues 

	  // See "man combat" (and "sman cb_tohit" and "man cb_tohit") 
	if (query_combat_object()->cb_tohit(W_NONE, 55, enemy) <= 0) 
	{ 
		tell_object(enemy, query_The_name(enemy) + 
						   " misses you with an attempted head-butt" +
						   " and falls flat on " + query_possessive() + 
						   " face.\n"); 
		tell_watcher(QCTNAME(this_object()) + " misses " + 
					 QTNAME(enemy) + " with an attempted head-butt" +
					 " and falls flat on " + query_possessive() + 
					 " face.\n", enemy); 
		command(({"grumble", "sigh", "swear"})[random(3)]); 
		return 0; // Combat round continues 
	} 

	stun_duration = 8 + random(15);   // Stun duration in seconds 
	switch (stun_duration) 
	{
		case 1..12 : 
			impact = " a glancing "; 
			reaction = " feel a bit groggy"; 
			onlooker_reaction = " looks a bit groggy"; 
			break; 
		case 13..17 : 
			impact = " a powerful "; 
			reaction = " feel quite dizzy"; 
			onlooker_reaction = " looks quite dizzy"; 
			break; 
		default : 
			impact = " a vicious ";
			reaction = " feel very shocked"; 
			onlooker_reaction = " looks very shocked"; 
			break; 
	} 

	tell_object(enemy, query_The_name(enemy) + " strikes you with" + 
				impact + "head-butt. You" + reaction + ".\n"); 
	tell_watcher(QCTNAME(this_object()) + " strikes " + QTNAME(enemy) + 
				 " with" + impact + "head-butt. " + QCTNAME(enemy) + 
				 onlooker_reaction + ".\n", enemy); 
	enemy->add_attack_delay(stun_duration, 1);	 // Standard stun handling. 

	return 0;	// Combat round continues 
} 
}
${63:/* 
 * Function:      greet
 * Description:   This function makes the npc do a greeting to people it
 *				  already know and to fellow npc's. It is possible to
 *				  redefine, note however that it should never contain an
 *				  'introduce myself' command.
 * Arguments:	  object who - the living that introduced to me
 *
 */					  
public void
greet(object who)
{
	  // He won't greet an enemy! 
	if (member_array(who, query_enemy(-1)) > -1) 
	{ 
		command("kick " + OB_NAME(who)); 
	} 
	else if (!objectp(query_attack())) 
	{  
		command("nod briefly " + OB_NAME(who)); 
	} 
} 
}
${64:/* 
 * Function:	 introduce 
 * Description:	 This function makes the npc do an introduction to a 
 *				 player that has not been introed to it earlier. The 
 *				 function may be redefined to create variety. 
 * Arguments: 	 object who - the living that introduced to me 
 * 
 */
public void 
introduce(object who)
{
	  // He won't intro to an enemy 
	if (member_array(who, query_enemy(-1)) > -1) 
	{ 
		command("kick " + OB_NAME(who)); 
	} 
	else 
	{ 
		command("introduce myself to " + OB_NAME(who)); 
		command("bow " + OB_NAME(who)); 
	} 
} 
}
${65:/* 
 * Function:	  notify_attacked 
 * Description:   Called from an associated npc when it is attacked, 
 *				  for example one in the same team. This npc will 
 *				  assist if not already fighting. 
 * Arguments:	  object friend -	the friend who was attacked 
 *				  object attacker - the attacker 
 */ 
void
notify_attacked(object friend, object attacker)
{
   // If not fighting anyone, assist. 
	if (!objectp(query_attack())) 
	{ 
		command("assist " + OB_NAME(friend)); 
	} 
}
}
${66:/* 
 * Function:	react_attack 
 * Description: React to an attack. This called by alarm from 
 *				the function "attacked_by" below. 
 * Arguments:	object attacker  -	the attacker. 
 */ 
void 
react_attack(object attacker)
{
	   // Vary reactions depending on darkness/invisibility 
	if (!CAN_SEE_IN_ROOM(this_object())) 
	{ 
		command("say Dark or light, you're dead!"); 
	} 
	else if (!CAN_SEE(this_object(), attacker)) 
	{ 
		command("say Curse you, who did that?!"); 
	} 
	else 
	{ 
		command("say to " + OB_NAME(attacker) + 
			" May your deathwish be granted, fool!"); 
	} 

	  /* 
	   * Here you could give team-members the chance to react. 
	   * The called function would have to be defined in them. 
	   */ 
	query_team_others()->notify_attacked(this_object(), attacker); 

	  /* 
	   *   To assemble a team of npcs, somewhere there must be 
	   *   code to choose a leader and call team_join(team_member) 
	   *   for each team-mate. This could be carried out in 
	   *   the code that clones the npcs, for example, or 
	   *   alternatively in the npc code itself - when they 
	   *   first encounter each other. Here, the former case 
	   *   is assumed. 
	   */ 
}
}
${67:/* 
 *	 Function:	   attacked_by 
 *	 Description:  Called by the combat system when a living is 
 *				   attacked. See "sman attacked_by" for documentation. 
 *	 Arguments:    object attacker	-  the attacking living. 
 */ 
public void 
attacked_by(object attacker) 
{ 
	::attacked_by(attacker); 
	set_alarm(1.0, 0.0, &react_attack(attacker)); 
} 
}
${68:/* 
 * Function:	 react_aggression 
 * Description:  Called from this npc's implementation of "emote_hook" 
 *				 when he receives a threatening or offensive emote. 
 * Arguments:	 emote	 -	the verb of the emote e.g. "kick" 
 *				 actor	 -	the emote actor 
 */ 
void 
react_aggression(string emote, object actor) 
{
	if (member_array(actor, query_enemy(-1)) > -1) 
	{ 
		command("finger " + OB_NAME(actor)); 
	} 
	else if (!objectp(query_attack())) 
	{ 
		command("kill " + OB_NAME(actor)); 
	} 
}

/*
 * Function:    emote_hook
 * Description: This hook is called whenever an emotion is performed on this
 *			    NPC. If it is an emotion that we hook on, call a little
 *				alarm and then call the return function.
 * Arguments:   string emote	- the emotion performed.
 *				object actor	- the actor of the emotion.
 *				string adverb - the adverb used in the emotion.
 *				object *targets - the targets of the emotion
 *				int cmd_attrs - the command's attributes (from cmdparse.h)
 */
void
emote_hook(string emote, object actor, string adverb, object *targets,
	int cmd_attrs)
{
	function f;

	/* We could maintain a list of emotes that we react to. Instead,
	 * we just look for a function that has the same name as the emote.
	 * If one exists, then we have defined a reaction for that emote!
	 */
	if (f = mkfunction(emote, this_object()))
	{
		/* We have found a function that matches the emote name, so
		 * we wait three seconds before calling the function with
		 * the actor and the adverb as arguments. 
		 */
		set_alarm(3.0, 0.0, &f(actor, adverb));
	}

	/* In addition to those emotes we want to respond to specifically,
	 * we want to respond to offensive emotes which have been targeted
	 * at this npc.  To do that, we'll examine the attributes of the
	 * action to see if it has been classified offensive.
	 */
	if (cmd_attrs & ACTION_OFFENSIVE)
	{
		/* See if this npc was among the targets of the emote */
		if (sizeof(targets) && (member_array(this_object(), targets) >= 0))
	{
			set_alarm(3.0, 0.0, &react_aggression(adverb, actor));
	}
	}
}
${69:
/*
 * Function:    emote_hook_onlooker
 * Description: This hook is called whenever an emotion is performed on a
 *			    third party in the room. Normally we don't bother to react
 *			    on emotions on others, unless someone is spitting. As the
 *			    alchemist doesn't like spitting at all, he reacts to it.
 * Arguments:   string emote	- the emotion performed.
 *			    object actor	- the actor of the emotion.
 *			    string adverb   - the adverb used in the emotion.
 *			    object *targets - the targets of the emotion.
 *			    int cmd_attrs   - the command's attributes (from cmdparse.h)
 */
void
emote_hook_onlooker(string emote, object actor, string adverb, object *targets,
	int cmd_attrs)
{
	/* Only react to spitting. */
	if (emote == "spit")
	{
	/* As we know the function we are going to call, we can use it in
	 * the alarm directly in the form of a function pointer.
	 */
	set_alarm(3.0, 0.0, &spit(adverb, actor));
	}
}}
}
${70:/* 
 *	Function:	 react_give 
 *	Description: React to receiving an object from a living. This 
 *				 is called by alarm from "enter_inv" below. Most 
 *				 monsters deal with attempts to give items to them 
 *				 in the default way, i.e. just they don't accept. 
 *				 This guy accepts and responds though. 
 * 
 *	Arguments:	 object gift	-	 the given object 
 *				 object giver	-	 the living who gave it 
 */ 
void 
react_give(object gift, object giver) 
{ 
	  /* 
	   * If the gift giver has gone or can't be seen, what should 
	   * be done? This monster will get suspicious and drop the 
	   * item. 
	   */ 
	if (!objectp(giver) || 
		!objectp(present(giver, environment(this_object()))) || 
		!CAN_SEE(this_object(), giver) ||
		!CAN_SEE_IN_ROOM(this_object())) 
	{ 
		command("peer suspiciously"); 
		command("drop " + OB_NAME(giver)); 
		return; 
	} 
	   // .. else if the giver is an enemy, don't accept it.. 
	else if (member_array(giver, query_enemy(-1)) > -1) 
	{ 
		if (query_attack() == giver) 
		{ 
			command("thank " + OB_NAME(giver) + " sarcastically"); 
			command("poke " + OB_NAME(giver) + " eye"); 
		} 
		command("drop " + OB_NAME(gift)); 
		return; 
	} 
	  /* 
	   * .. else if the item is important to the monster, do something 
	   * with it. Here's just an illustrative example. Provided 
	   * he is not poisoned and the item contains alcohol, he'll 
	   * drink it .. 
	   */ 
	else if (!objectp(present("poison", this_object())) && 
			 gift->query_alco_amount() > 0) 
	{ 
		command("grin " + OB_NAME(giver)); 
		  // .. try to drink it 
		if (command("drink " + OB_NAME(gift))) // if he could drink it .. 
		{ 
			  // .. if he's now poisoned, attack the giver. 
			if (objectp(present("poison", this_object()))) 
			{ 
				command("scowl " + OB_NAME(giver)); 
				command("kill " + OB_NAME(giver)); 
			} 
			else 
			{ 
				command("smile " + OB_NAME(giver)); 
				command("thank " + OB_NAME(giver)); 
			} 
			return; 
		} 
		command("shrug"); 
	} 

	  // give it back 
	command("say Keep this!"); 
	if (!command("give " + OB_NAME(gift) + " to " + 
				 OB_NAME(giver))) 
	{ 
		command("drop " + OB_NAME(gift)); 
	} 
} 

/* 
 * Function:    enter_inv
 * Description: very useful and widely used. In this case it's 
 *              used in reacting to something given to this monster 
 * Arguments:   object obj - what is given
 *              object from - from whom
 */ 
void 
enter_inv(object obj, object from) 
{ 
	  // Call the inherited function code 
	::enter_inv(obj, from); 

	  // If it's a gift, set up a reaction one second after.. 
	if (living(from)) 
		set_alarm(1.0, 0.0, &react_give(obj, from)); 
} 
}
${71:
/*
 * Function:    block_action
 * Description: This is called to see if the npc wants to prevent
 *				a certain action from being targeted on it.
 * Arguments:	string cmd - the name of the command that is being used
 *				object actor - the actor
 *				int cmd_attrs - the commands attributes (from cmdparse.h)
 * Returns:		0 - The command is not blocked
 *				1 - The command is blocked, but no failure message should
 *					be giving.
 *				string - The command is blocked, and the return value
 *					     should be used as the failure message.
 */
mixed
block_action(string cmd, object actor, int cmd_attrs)
{
	/* See if the action is classified as a contact action */
	if (cmd_attrs & ACTION_CONTACT)
	{
		/* The action is contact, so return a failure message */
		return "The ghost is immaterial.  You cannot touch it!\n";
	}

	/* The action isn't classified as a contact action, so let it
	 * continue.
	 */
	return 0;
}
}
endsnippet

post_jump "clean_description()"
snippet create_creature "Create a creature" b
#define $35	1
#define $41 2
#define $47 4

#define $53 1
#define $57 2

/*
 * Function:	create_creature
 * Description: $5
 */
create_creature()
{
	set_name("${1:name}");

	set_adj("${2:first adjective}");
	add_adj("${3:second adjective}");
	set_race_name("${4:race}");

	set_short("${5:$3 $2 $4}");

	/*-{
		Description: 
					${6:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[6])`);

	set_gender(G_${7:MALE});
	set_alignment(${8:0, between -1200 and 1200});

	set_hp(query_max_hp());

	add_prop(CONT_I_HEIGHT, ${12:height [cm]});
	add_prop(CONT_I_WEIGHT, ${13:weight [g]});
	add_prop(CONT_I_VOLUME, ${14:volume w/o inventory [ml]});

	add_prop(LIVE_I_NO_BODY, ${15:0});
	add_prop(LIVE_I_UNDEAD, ${16:15, [0-100 max] - how strong it resist undead turning});
	add_prop(LIVE_I_NEVERKNOWN, ${17:1});

	set_aggressive(${19:1});

	set_stats(({ ${20:STR [0-250]}, ${21:DEX}, ${22:CON}, ${23:INT}, ${24:WIS}, ${25:DIS} }), ${26:deviation [0-50%]});

	set_skill(SS_${31:DEFENCE}, ${32:30}); 
	set_skill(SS_${33:SWIM}, ${34:80}); 

	set_attack_unarmed(${35:A_BITE}, ${36:20 - hit}, ${37:30 - pen}, W_${38:IMPALE}, ${39:40 - chance of use [%]}, "${40:jaws}");
	set_attack_unarmed(${41:A_LCLAW}, ${42:40 - hit}, ${43:20 - pen}, W_${44:SLASH},  ${45:30 - chance of use [%]}, "${46:left paw}");
	set_attack_unarmed(${47:A_RCLAW}, ${48:40 - hit}, ${49:20 - pen}, W_${50:SLASH},  ${51:30 - chance of use [%]}, "${52:right paw}");

	set_hitloc_unarmed(${53:H_HEAD}, ${54:({ 15, 25, 20,})}, ${55:20 [% of body]}, "${56:head}");
	set_hitloc_unarmed(${57:H_BODY}, ${58:({ 10, 15, 30,})}, ${59:80 [% of body]}, "${60:body}");

	set_act_time(${61:5});
	add_act("${62:stare}");

	set_cact_time(${63:2}); 
	add_cact("${64:scowl savagely}"); 
	add_cact("${65:growl}");

	add_prop(LIVE_I_NO_CORPSE, ${66:0});
	add_leftover("${67:/std/leftover}", "${68:organ}", ${69:# items on body}, ${70:vbfc to check on tear/cut or 0}, ${71:0/1 hard remains? (left after decay)}, ${72:1/0 cut/tear}, ${73:weight [corpse/1000 pts]});

	${74:
	// Movement
	set_random_move(10);}
}

/* 
 * Function:	special_attack
 * Description: special_attack() is called by the standard combat
 * Arguments:	object enemy - target
 * Returns:		0/1 - round continues or it is done (prevent plain attack)
 */ 
int
special_attack(object enemy)
{
	object me;
	mixed *hitresult;
	string how;

	// Only execute the special attack 1 in 10 rounds
	if (random(10)) return 0;

	hitresult = enemy->hit_me(20+random(30), W_IMPALE, me, -1);
	switch (hitresult[0])
	{
		case 0:
			how = "unwounded";
			break;
		case 1..10:
			how = "barely wounded";
			break;
		case 11..20:
			how = "wounded";
			break;
		default:
			how = "seriously wounded";
			break;
	}

	enemy->catch_tell(QTNAME(enemy) + " tears into your throat!\n"+
			 "You are " + how + ".\n");
	tell_watcher(QCTNAME(me) + " tears into " + QTNAME(enemy) + "!\n" +
		capitalize(HE(enemy)) + " is " + how + ".\n", enemy);

	if (enemy->query_hp() <= 0)
	{
		enemy->do_die(this_object());
	}
	
	//  Important! Should not have two attacks in a round.
	return 1;
}
endsnippet

post_jump "clean_description()"
snippet create_messenger "Create a messenger (creature)" b
#define MESSAGE_OBJ     "/doc/examples/obj/message"

/*
 * Function:	create_messenger
 * Description: Set all the options in this function. It overrides the
 *				defaults set in init_messenger since it is the last
 *				function called by init_messenger.
 */
public void
create_messenger()
{
	set_name("${1:name}");
	set_pname("${2:${1/^(name)|(.*)$/(?1:plural:$2s)/}}");

	set_adj("${2:first adjective}");
	add_adj("${3:second adjective}");
	set_race_name("${4:race}");

	set_short("${5:$3 $2 $4}");

	/*-{
		Description: 
					${6:Long description}
	}-*/
	set_long(`!p snip.rv=qwrap(t[6])`);

	set_gender(G_${7:MALE});
	set_alignment(${8:0, between -1200 and 1200});

	set_hp(query_max_hp());

	add_prop(CONT_I_HEIGHT, ${12:height [cm]});
	add_prop(CONT_I_WEIGHT, ${13:weight [g]});
	add_prop(CONT_I_VOLUME, ${14:volume w/o inventory [ml]});

	add_prop(LIVE_I_NO_BODY, ${15:0});
	add_prop(LIVE_I_UNDEAD, ${16:15, [0-100 max] - how strong it resist undead turning});
	add_prop(LIVE_I_NEVERKNOWN, ${17:1});

	set_stats(({ ${20:STR [0-250]}, ${21:DEX}, ${22:CON}, ${23:INT}, ${24:WIS}, ${25:DIS} }), ${26:deviation [0-50%]});

	set_skill(SS_${31:DEFENCE}, ${32:30}); 
	set_skill(SS_${33:SWIM}, ${34:80}); 

	set_attack_unarmed(${35:A_BITE}, ${36:20 - hit}, ${37:30 - pen}, W_${38:IMPALE}, ${39:40 - chance of use [%]}, "${40:jaws}");
	set_attack_unarmed(${41:A_LCLAW}, ${42:40 - hit}, ${43:20 - pen}, W_${44:SLASH},  ${45:30 - chance of use [%]}, "${46:left paw}");
	set_attack_unarmed(${47:A_RCLAW}, ${48:40 - hit}, ${49:20 - pen}, W_${50:SLASH},  ${51:30 - chance of use [%]}, "${52:right paw}");

	set_hitloc_unarmed(${53:H_HEAD}, ${54:({ 15, 25, 20,})}, ${55:20 [% of body]}, "${56:head}");
	set_hitloc_unarmed(${57:H_BODY}, ${58:({ 10, 15, 30,})}, ${59:80 [% of body]}, "${60:body}");

	set_act_time(${61:5});
	add_act("${62:stare}");

	set_cact_time(${63:2}); 
	add_cact("${64:scowl savagely}"); 
	add_cact("${65:growl}");

	add_prop(LIVE_I_NO_CORPSE, ${66:0});
	add_leftover("${67:/std/leftover}", "${68:organ}", ${69:# items on body}, ${70:vbfc to check on tear/cut or 0}, ${71:0/1 hard remains? (left after decay)}, ${72:1/0 cut/tear}, ${73:weight [corpse/1000 pts]});

	${74:
	// Movement
	set_random_move(10);}
	
	set_can_deliver_indoors(${80:1});
	set_can_deliver_unmet(${81:1});
	set_message_object_file(${82:MESSAGE_OBJ});
	set_number_of_uses(${83:5});		   
}

/*
 * Function:	hook_send_message
 * Description: Hook that gets called to display the message of the
 *				messenger getting the message and leaving to deliver it
 */
public void
hook_send_message()
{
	this_player()->catch_msg("You hand your message to "
		+ QTNAME(this_object()) + ".\n");
	say(QCTNAME(this_player()) + " hands a message to " 
	+ this_player()->query_possessive() + " " 
	+ QSHORT(this_object()) + ".\n");
	tell_room(environment(this_player()), QCTNAME(this_object()) 
	+ " jogs off to deliver a message.\n");	
}

/*
 * Function:	hook_resend_message
 * Description: Hook that gets called to display the message of the
 *				messenger being asked to re-deliver after a failed attempt.
 */
public void
hook_resend_message()
{
	this_player()->catch_msg("You instruct " + QTNAME(this_object()) 
	+ " to make yet another try.\n");
	say(QCTNAME(this_player()) + " instructs " 
	+ this_player()->query_possessive() + " " + QSHORT(this_object()) 
	+ " to make yet another try.\n");
	tell_room(environment(this_player()), QCTNAME(this_object()) 
	+ " jogs off to deliver a message.\n");	
}

/*
 * Function:	hook_deliver_message_failure
 * Description: Hook that gets called to display the message of the
 *				the messenger being unable to deliver the message and
 *				returning to the sender.
 * Arguments:	sender - the person who sent the message
 */
public void		
hook_deliver_message_failure(object sender)
{
	sender->catch_msg("Your " + QSHORT(this_object()) + " returns unable "
	+ "to find " + capitalize(gReceiver) + ".\n");
	tell_room(environment(sender), QCNAME(this_object()) + " arrives "
	+ "jogging and hands " + QTNAME(sender) + " a message.\n", sender);
}

/*
 * Function:	hook_deliver_message_success
 * Description: Hook that gets called to display the message of the
 *				messenger successfully delivering the message to the
 *				recipient.
 * Arguments:	receiver - the person receiving the message
 */
public void		
hook_deliver_message_success(object receiver)
{
	receiver->catch_msg(QCNAME(this_object()) + " arrives jogging and hands "
	+ "you a message from " + capitalize(gSender) + ".\n");
	tell_room(environment(receiver), QCNAME(this_object()) 
	+ " arrives jogging and hands " + QTNAME(receiver) 
	+ " a message.\n", receiver);
}

/*
 * Function:	hook_messenger_returns_home
 * Description: Hook that gets called to display the message of the
 *				messenger returning home after either being used up or
 *				being asked to return home.
 */
public void
hook_messenger_returns_home()
{
	object room;

	if (living(room = environment(this_object())))
	{
	room = environment(room);
	}
	tell_room(room, QCTNAME(this_object()) + " jogs away.\n");
}

/*
 * Function:	hook_cannot_deliver_player_unavailable
 * Description: Hook that gets called to display that the messenger cannot
 *				deliver to someone who is either LD or not in the game.
 * Arguments:	who - the person the sender is trying to send to
 * Returns:		nothing
 */
public void
hook_cannot_deliver_player_unavailable(string who)
{
	notify_fail(capitalize(LANG_THESHORT(this_object()))
	   + " looks at you confusedly, unable to understand who " 
	   + capitalize(who) + " is!\n");
}
endsnippet
# }}}

# vim: sts=4:ts=4:sw=4:foldmethod=marker
